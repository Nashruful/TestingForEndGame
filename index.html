<!-- public/index.html -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Simple Quiplike (demo)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; padding: 24px; max-width: 720px; margin: auto; }
    .hidden { display:none; }
    .card { border:1px solid #ddd; padding:16px; border-radius:8px; margin-bottom:12px; }
    button { padding:8px 12px; margin:6px 0; }
    input[type="text"] { padding:8px; width:100%; box-sizing:border-box; margin-bottom:8px; }
    textarea { width:100%; height:100px; box-sizing:border-box; padding:8px; }
  </style>
</head>
<body>
  <h1>Simple Quiplike — Demo</h1>

  <div id="join" class="card">
    <h3>Join a room</h3>
    <label>Your Name</label>
    <input id="name" type="text" placeholder="Your name" />
    <label>Room code</label>
    <input id="code" type="text" placeholder="ABCD" />
    <div>
      <button id="joinBtn">Join</button>
      <button id="createBtn">Create room (be host)</button>
    </div>
    <div id="joinMsg"></div>
  </div>

  <div id="lobby" class="card hidden">
    <h3>Lobby — Room <span id="roomCode"></span></h3>
    <div>Host: <span id="hostName"></span></div>
    <div>Players (<span id="playerCount"></span>/4):</div>
    <ul id="playersList"></ul>
    <div id="ownerControls" style="margin-top:8px;">
      <button id="startBtn">Start game (only host)</button>
    </div>
    <div id="lobbyMsg"></div>
  </div>

  <div id="answer" class="card hidden">
    <h3>Question</h3>
    <div id="questionText"></div>
    <div style="margin-top:8px;">
      <label>Your answer</label>
      <textarea id="answerText"></textarea>
      <div>
        <button id="submitAnswerBtn">Submit answer</button>
      </div>
      <div id="answerMsg"></div>
    </div>
    <div>Answers submitted: <span id="answersCount"></span></div>
    <div>Time left: <span id="timeLeft"></span></div>
  </div>

  <div id="voting" class="card hidden">
    <h3>Vote between two answers</h3>
    <div id="voteQuestion"></div>
    <div id="pairArea" style="display:flex;gap:12px;margin-top:12px;">
      <div style="flex:1" class="card">
        <div id="optAName"></div>
        <div id="optAAnswer"></div>
        <button id="voteA">Vote A</button>
      </div>
      <div style="flex:1" class="card">
        <div id="optBName"></div>
        <div id="optBAnswer"></div>
        <button id="voteB">Vote B</button>
      </div>
    </div>
    <div id="votesCount">Votes: 0</div>
    <div id="votingTimeLeft">Time left: <span id="votingTimeLeftSpan"></span></div>
    <div id="votingMsg"></div>
  </div>

  <div id="results" class="card hidden">
    <h3>Results</h3>
    <div id="resultsList"></div>
    <div><button id="backToJoin">Back to join screen</button></div>
  </div>

<script>
const apiBase = 'https://endgame-back-end.onrender.com';
let pollInterval = null;
let state = null;

function el(id){ return document.getElementById(id); }

function show(id){ document.querySelectorAll('.card').forEach(c=>c.classList.add('hidden')); el(id).classList.remove('hidden'); }

function saveLocal(playerId, name, code){ localStorage.setItem('q_playerId', playerId); localStorage.setItem('q_name', name); localStorage.setItem('q_code', code); }
function loadLocal(){ return { playerId: localStorage.getItem('q_playerId'), name: localStorage.getItem('q_name'), code: localStorage.getItem('q_code') }; }
function clearLocal(){ localStorage.removeItem('q_playerId'); localStorage.removeItem('q_name'); localStorage.removeItem('q_code'); }

async function api(path, opts = {}) {
  const res = await fetch(apiBase + path, opts);
  if (!res.ok) {
    const t = await res.text();
    throw new Error('API error: ' + res.status + ' ' + t);
  }
  return res.json();
}

async function createRoom(name) {
  const r = await api('/rooms', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ name }) });
  return r;
}

async function joinRoom(code, name) {
  const r = await api('/rooms/' + encodeURIComponent(code) + '/join', {
    method:'POST',
    headers:{'content-type':'application/json'},
    body: JSON.stringify({ name })
  });
  return r;
}

async function startRoom(code, ownerToken) {
  const r = await api('/rooms/' + encodeURIComponent(code) + '/start', {
    method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ ownerToken })
  });
  return r;
}

async function submitAnswer(code, playerId, answer) {
  return api('/rooms/' + encodeURIComponent(code) + '/answer', {
    method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ playerId, answer })
  });
}

async function submitVote(code, voterId, votedFor) {
  return api('/rooms/' + encodeURIComponent(code) + '/vote', {
    method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ voterId, votedFor })
  });
}

async function getState(code, playerId) {
  const url = '/rooms/' + encodeURIComponent(code) + '/state' + (playerId ? '?playerId=' + encodeURIComponent(playerId) : '');
  return api(url);
}

function startPolling(code, playerId) {
  if (pollInterval) clearInterval(pollInterval);
  fetchAndUpdate(code, playerId);
  pollInterval = setInterval(()=>fetchAndUpdate(code, playerId), 2000);
}

async function fetchAndUpdate(code, playerId) {
  try {
    const s = await getState(code, playerId);
    state = s;
    updateUI(s);
  } catch (err) {
    console.error('poll error', err);
    el('lobbyMsg').innerText = 'Error polling server: ' + err.message;
  }
}

function updateUI(s) {
  // show lobby or phase screens
  if (s.phase === 'lobby') {
    show('lobby');
    el('roomCode').innerText = s.code;
    el('hostName').innerText = s.ownerName;
    el('playerCount').innerText = s.players.length;
    const ul = el('playersList'); ul.innerHTML = '';
    s.players.forEach(p => { const li = document.createElement('li'); li.innerText = p.name; ul.appendChild(li); });
    // show start button only if you're the owner
    const loc = loadLocal();
    const isOwner = (loc && loc.name === s.ownerName && loc.playerId === null); // owner created via create flow stores ownerToken not playerId
    // we can't currently detect owner by playerId since owner used create route; we'll show startBtn only if owner token saved in localStorage
    const ownerToken = localStorage.getItem('q_ownerToken');
    el('ownerControls').style.display = ownerToken ? 'block' : 'none';
  } else if (s.phase === 'answer') {
    show('answer');
    el('questionText').innerText = s.question;
    el('answersCount').innerText = s.answersCount + ' / ' + s.maxPlayers;
    if (s.answerEndsAt) {
      const left = Math.max(0, Math.round((s.answerEndsAt - Date.now())/1000));
      el('timeLeft').innerText = left + 's';
    } else el('timeLeft').innerText = '';
    el('answerText').value = s.yourAnswer || '';
  } else if (s.phase === 'voting') {
    show('voting');
    el('voteQuestion').innerText = s.question;
    el('votesCount').innerText = 'Votes: ' + s.votesCount;
    if (s.yourPair) {
      el('optAName').innerText = s.yourPair.a.name || 'A';
      el('optAAnswer').innerText = s.yourPair.a.answer || '(no answer)';
      el('optBName').innerText = s.yourPair.b.name || 'B';
      el('optBAnswer').innerText = s.yourPair.b.answer || '(no answer)';
      el('voteA').dataset.target = s.yourPair.a.id;
      el('voteB').dataset.target = s.yourPair.b.id;
    } else {
      el('optAName').innerText = '(waiting...)';
      el('optAAnswer').innerText = '';
      el('optBName').innerText = '';
      el('optBAnswer').innerText = '';
    }
    if (s.votingEndsAt) {
      const left = Math.max(0, Math.round((s.votingEndsAt - Date.now())/1000));
      el('votingTimeLeftSpan').innerText = left + 's';
    }
  } else if (s.phase === 'results') {
    show('results');
    const out = el('resultsList'); out.innerHTML = '';
    (s.results || []).forEach(r => {
      const d = document.createElement('div');
      d.innerText = r.name + ' — ' + (r.answer || '(no answer)') + ' — points: ' + r.score;
      out.appendChild(d);
    });
  }
}

// event handlers
el('createBtn').addEventListener('click', async () => {
  const name = el('name').value.trim() || 'Host';
  try {
    const r = await createRoom(name);
    // store ownerToken for starting
    localStorage.setItem('q_ownerToken', r.ownerToken);
    // create a pseudo-player entry for the host UI (host does not have a playerId for this minimal flow)
    localStorage.setItem('q_name', name);
    localStorage.setItem('q_code', r.code);
    // open lobby (we must poll without playerId)
    startPolling(r.code, null);
    el('lobbyMsg').innerText = 'Room created. Tell players code: ' + r.code;
  } catch (err) {
    el('joinMsg').innerText = 'Error creating room: ' + err.message;
  }
});

el('joinBtn').addEventListener('click', async () => {
  const name = el('name').value.trim() || 'Player';
  const code = (el('code').value || '').trim().toUpperCase();
  if (!code) { el('joinMsg').innerText = 'Enter room code'; return; }
  try {
    const r = await joinRoom(code, name);
    saveLocal(r.playerId, name, code);
    localStorage.removeItem('q_ownerToken');
    startPolling(code, r.playerId);
    el('joinMsg').innerText = 'Joined as ' + name;
  } catch (err) {
    el('joinMsg').innerText = 'Join error: ' + err.message;
  }
});

el('startBtn').addEventListener('click', async () => {
  const ownerToken = localStorage.getItem('q_ownerToken');
  const code = localStorage.getItem('q_code');
  if (!ownerToken || !code) { el('lobbyMsg').innerText = 'No owner token found.'; return; }
  try {
    await startRoom(code, ownerToken);
    el('lobbyMsg').innerText = 'Game started.';
    startPolling(code, localStorage.getItem('q_playerId'));
  } catch (err) {
    el('lobbyMsg').innerText = 'Start error: ' + err.message;
  }
});

el('submitAnswerBtn').addEventListener('click', async () => {
  const loc = loadLocal();
  const code = loc.code;
  const playerId = loc.playerId;
  const answer = el('answerText').value.trim();
  if (!answer) { el('answerMsg').innerText = 'Enter answer first.'; return; }
  try {
    await submitAnswer(code, playerId, answer);
    el('answerMsg').innerText = 'Answer submitted.';
  } catch (err) {
    el('answerMsg').innerText = 'Submit error: ' + err.message;
  }
});

el('voteA').addEventListener('click', async (ev) => {
  const target = ev.currentTarget.dataset.target;
  const loc = loadLocal();
  try {
    await submitVote(loc.code, loc.playerId, target);
    el('votingMsg').innerText = 'Voted.';
  } catch (err) {
    el('votingMsg').innerText = 'Vote error: ' + err.message;
  }
});
el('voteB').addEventListener('click', async (ev) => {
  const target = ev.currentTarget.dataset.target;
  const loc = loadLocal();
  try {
    await submitVote(loc.code, loc.playerId, target);
    el('votingMsg').innerText = 'Voted.';
  } catch (err) {
    el('votingMsg').innerText = 'Vote error: ' + err.message;
  }
});

el('backToJoin').addEventListener('click', () => {
  clearLocal();
  location.reload();
});

// on load: if local data present, auto-poll
window.addEventListener('load', () => {
  const loc = loadLocal();
  if (loc && loc.code) {
    // if we have playerId -> joined; otherwise just host view
    startPolling(loc.code, loc.playerId);
  } else {
    show('join');
  }
});
</script>
</body>
</html>
